# Hash Tables - Data Structure Fundamentals

## What is a Hash Table?

A **hash table** (also called hash map) is a data structure that implements an associative array abstract data type, mapping keys to values. It uses a hash function to compute an index (hash code) into an array of buckets or slots, from which the desired value can be found.

### Key Characteristics:
- **Fast Access**: Average O(1) time complexity for search, insert, and delete
- **Key-Value Mapping**: Associates unique keys with values
- **Hash Function**: Converts keys into array indices
- **Collision Handling**: Manages multiple keys hashing to same index
- **Dynamic Sizing**: Can grow/shrink based on load factor

```python
# Visual representation of a hash table
# Hash Table with size 7:
# Index:  0    1    2    3    4    5    6
# Data:  [John] [] [Alice] [] [Bob] [] [Charlie]
#
# Hash function: hash(key) % 7
# "John" → hash("John") % 7 = 0
# "Alice" → hash("Alice") % 7 = 2
# "Bob" → hash("Bob") % 7 = 4
# "Charlie" → hash("Charlie") % 7 = 6
```

## How Hash Tables Work Internally

### Hash Function Fundamentals
```python
def demonstrate_hash_functions():
    """Demonstrate different hash function approaches"""
    
    def simple_hash(key, table_size):
        """Simple hash function - sum of ASCII values"""
        if isinstance(key, str):
            return sum(ord(c) for c in key) % table_size
        return hash(key) % table_size
    
    def djb2_hash(key, table_size):
        """DJB2 hash function - widely used string hash"""
        hash_value = 5381
        for char in str(key):
            hash_value = ((hash_value << 5) + hash_value) + ord(char)
        return hash_value % table_size
    
    def polynomial_hash(key, table_size, base=31):
        """Polynomial rolling hash"""
        hash_value = 0
        for i, char in enumerate(str(key)):
            hash_value += ord(char) * (base ** i)
        return hash_value % table_size
    
    def multiplicative_hash(key, table_size):
        """Multiplicative hash using golden ratio"""
        A = 0.6180339887  # (sqrt(5) - 1) / 2
        if isinstance(key, str):
            key_value = sum(ord(c) for c in key)
        else:
            key_value = hash(key)
        
        return int(table_size * ((key_value * A) % 1))
    
    # Test different hash functions
    keys = ["apple", "banana", "cherry", "date", "elderberry"]
    table_size = 11
    
    print("Hash Function Comparison:")
    print("Key        | Simple | DJB2  | Polynomial | Multiplicative")
    print("-" * 60)
    
    for key in keys:
        simple = simple_hash(key, table_size)
        djb2 = djb2_hash(key, table_size)
        poly = polynomial_hash(key, table_size)
        mult = multiplicative_hash(key, table_size)
        
        print(f"{key:10} | {simple:6} | {djb2:5} | {poly:10} | {mult:12}")
    
    # Analyze hash distribution
    print(f"\nHash Distribution Analysis (table size: {table_size}):")
    
    for name, func in [("Simple", simple_hash), ("DJB2", djb2_hash), 
                       ("Polynomial", polynomial_hash), ("Multiplicative", multiplicative_hash)]:
        distribution = [0] * table_size
        for key in keys:
            index = func(key, table_size)
            distribution[index] += 1
        
        # Calculate standard deviation for uniformity
        mean = len(keys) / table_size
        variance = sum((x - mean) ** 2 for x in distribution) / table_size
        std_dev = variance ** 0.5
        
        print(f"{name:13} - Distribution: {distribution}, Std Dev: {std_dev:.2f}")

demonstrate_hash_functions()
```

### Collision Resolution Techniques
```python
class HashTableChaining:
    """Hash table with separate chaining for collision resolution"""
    
    def __init__(self, initial_capacity=8):
        self.capacity = initial_capacity
        self.size = 0
        self.buckets = [[] for _ in range(self.capacity)]
        self.load_factor_threshold = 0.75
        
    def _hash(self, key):
        """Hash function using built-in hash with modulo"""
        return hash(key) % self.capacity
    
    def _resize(self):
        """Resize the hash table when load factor exceeds threshold"""
        old_buckets = self.buckets
        old_capacity = self.capacity
        
        self.capacity *= 2
        self.size = 0
        self.buckets = [[] for _ in range(self.capacity)]
        
        # Rehash all existing elements
        for bucket in old_buckets:
            for key, value in bucket:
                self.put(key, value)
        
        print(f"Resized hash table from {old_capacity} to {self.capacity}")
    
    def put(self, key, value):
        """Insert or update key-value pair"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        # Check if key already exists
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # Update existing
                return
        
        # Add new key-value pair
        bucket.append((key, value))
        self.size += 1
        
        # Check if resize is needed
        if self.size / self.capacity > self.load_factor_threshold:
            self._resize()
    
    def get(self, key):
        """Retrieve value by key"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        raise KeyError(f"Key '{key}' not found")
    
    def delete(self, key):
        """Remove key-value pair"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                self.size -= 1
                return v
        
        raise KeyError(f"Key '{key}' not found")
    
    def contains(self, key):
        """Check if key exists"""
        try:
            self.get(key)
            return True
        except KeyError:
            return False
    
    def keys(self):
        """Get all keys"""
        result = []
        for bucket in self.buckets:
            for key, _ in bucket:
                result.append(key)
        return result
    
    def values(self):
        """Get all values"""
        result = []
        for bucket in self.buckets:
            for _, value in bucket:
                result.append(value)
        return result
    
    def items(self):
        """Get all key-value pairs"""
        result = []
        for bucket in self.buckets:
            for key, value in bucket:
                result.append((key, value))
        return result
    
    def display_structure(self):
        """Display internal structure"""
        print(f"Hash Table Structure (size: {self.size}, capacity: {self.capacity}):")
        print(f"Load factor: {self.size / self.capacity:.2f}")
        
        for i, bucket in enumerate(self.buckets):
            if bucket:
                print(f"Bucket {i}: {bucket}")
            else:
                print(f"Bucket {i}: []")
    
    def get_statistics(self):
        """Get collision statistics"""
        non_empty_buckets = sum(1 for bucket in self.buckets if bucket)
        max_chain_length = max(len(bucket) for bucket in self.buckets)
        avg_chain_length = self.size / non_empty_buckets if non_empty_buckets > 0 else 0
        
        return {
            'total_buckets': self.capacity,
            'non_empty_buckets': non_empty_buckets,
            'max_chain_length': max_chain_length,
            'avg_chain_length': avg_chain_length,
            'load_factor': self.size / self.capacity
        }

# Demonstrate chaining hash table
def demonstrate_chaining():
    ht = HashTableChaining(5)  # Small capacity to force collisions
    
    # Insert key-value pairs
    items = [("apple", 1), ("banana", 2), ("cherry", 3), ("date", 4), 
             ("elderberry", 5), ("fig", 6), ("grape", 7)]
    
    print("Inserting items into hash table with chaining:")
    for key, value in items:
        ht.put(key, value)
        print(f"Inserted '{key}': {value}")
    
    print("\n" + "="*50)
    ht.display_structure()
    
    print("\nStatistics:")
    stats = ht.get_statistics()
    for key, value in stats.items():
        print(f"{key.replace('_', ' ').title()}: {value}")
    
    # Test operations
    print(f"\nTesting operations:")
    print(f"Get 'apple': {ht.get('apple')}")
    print(f"Contains 'banana': {ht.contains('banana')}")
    print(f"All keys: {ht.keys()}")

demonstrate_chaining()
```

### Open Addressing (Linear Probing)
```python
class HashTableOpenAddressing:
    """Hash table with open addressing using linear probing"""
    
    def __init__(self, initial_capacity=8):
        self.capacity = initial_capacity
        self.size = 0
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.deleted = [False] * self.capacity  # Track deleted slots
        self.load_factor_threshold = 0.5  # Lower threshold for open addressing
    
    def _hash(self, key):
        """Hash function"""
        return hash(key) % self.capacity
    
    def _find_slot(self, key):
        """Find slot for key using linear probing"""
        index = self._hash(key)
        original_index = index
        probes = 0
        
        while self.keys[index] is not None:
            if self.keys[index] == key and not self.deleted[index]:
                return index, probes  # Found existing key
            
            index = (index + 1) % self.capacity
            probes += 1
            
            # If we've probed all slots
            if index == original_index:
                return None, probes  # Table is full
        
        return index, probes  # Found empty slot
    
    def _resize(self):
        """Resize the hash table"""
        old_keys = self.keys
        old_values = self.values
        old_deleted = self.deleted
        old_capacity = self.capacity
        
        self.capacity *= 2
        self.size = 0
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.deleted = [False] * self.capacity
        
        # Rehash all existing elements
        for i in range(old_capacity):
            if old_keys[i] is not None and not old_deleted[i]:
                self.put(old_keys[i], old_values[i])
        
        print(f"Resized hash table from {old_capacity} to {self.capacity}")
    
    def put(self, key, value):
        """Insert or update key-value pair"""
        if self.size / self.capacity >= self.load_factor_threshold:
            self._resize()
        
        index, probes = self._find_slot(key)
        
        if index is None:
            raise Exception("Hash table is full")
        
        # If this is a new key
        if self.keys[index] is None or self.deleted[index]:
            self.size += 1
        
        self.keys[index] = key
        self.values[index] = value
        self.deleted[index] = False
        
        return probes
    
    def get(self, key):
        """Retrieve value by key"""
        index, probes = self._find_slot(key)
        
        if index is None or self.keys[index] != key or self.deleted[index]:
            raise KeyError(f"Key '{key}' not found")
        
        return self.values[index], probes
    
    def delete(self, key):
        """Remove key-value pair using lazy deletion"""
        index, probes = self._find_slot(key)
        
        if index is None or self.keys[index] != key or self.deleted[index]:
            raise KeyError(f"Key '{key}' not found")
        
        value = self.values[index]
        self.deleted[index] = True
        self.size -= 1
        
        return value, probes
    
    def display_structure(self):
        """Display internal structure"""
        print(f"Hash Table Structure (size: {self.size}, capacity: {self.capacity}):")
        print(f"Load factor: {self.size / self.capacity:.2f}")
        print("Index | Key        | Value | Deleted")
        print("-" * 40)
        
        for i in range(self.capacity):
            key = self.keys[i] if self.keys[i] is not None else "None"
            value = self.values[i] if self.values[i] is not None else "None"
            deleted = "Yes" if self.deleted[i] else "No"
            print(f"{i:5} | {str(key):10} | {str(value):5} | {deleted}")
    
    def get_probe_statistics(self):
        """Get probing statistics"""
        total_probes = 0
        max_probes = 0
        
        for i in range(self.capacity):
            if self.keys[i] is not None and not self.deleted[i]:
                expected_index = self._hash(self.keys[i])
                actual_distance = (i - expected_index) % self.capacity
                total_probes += actual_distance
                max_probes = max(max_probes, actual_distance)
        
        avg_probes = total_probes / self.size if self.size > 0 else 0
        
        return {
            'average_probes': avg_probes,
            'max_probes': max_probes,
            'total_probes': total_probes
        }

# Demonstrate open addressing
def demonstrate_open_addressing():
    ht = HashTableOpenAddressing(7)  # Small capacity to force probing
    
    items = [("apple", 1), ("banana", 2), ("cherry", 3), ("date", 4), ("elderberry", 5)]
    
    print("Inserting items into hash table with linear probing:")
    for key, value in items:
        probes = ht.put(key, value)
        print(f"Inserted '{key}': {value} (probes: {probes})")
    
    print("\n" + "="*50)
    ht.display_structure()
    
    print("\nProbe Statistics:")
    stats = ht.get_probe_statistics()
    for key, value in stats.items():
        print(f"{key.replace('_', ' ').title()}: {value:.2f}")
    
    # Test retrieval
    print(f"\nTesting retrieval:")
    try:
        value, probes = ht.get("cherry")
        print(f"Get 'cherry': {value} (probes: {probes})")
    except KeyError as e:
        print(e)

demonstrate_open_addressing()
```

### Double Hashing
```python
class HashTableDoubleHashing:
    """Hash table with double hashing for collision resolution"""
    
    def __init__(self, initial_capacity=11):  # Prime number for better distribution
        self.capacity = initial_capacity
        self.size = 0
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.deleted = [False] * self.capacity
    
    def _hash1(self, key):
        """Primary hash function"""
        return hash(key) % self.capacity
    
    def _hash2(self, key):
        """Secondary hash function for double hashing"""
        # Use a prime number smaller than capacity
        prime = 7
        return prime - (hash(key) % prime)
    
    def _find_slot(self, key):
        """Find slot using double hashing"""
        index = self._hash1(key)
        step = self._hash2(key)
        original_index = index
        probes = 0
        
        while self.keys[index] is not None:
            if self.keys[index] == key and not self.deleted[index]:
                return index, probes, step  # Found existing key
            
            index = (index + step) % self.capacity
            probes += 1
            
            # If we've probed all slots
            if index == original_index:
                return None, probes, step  # Table is full
        
        return index, probes, step  # Found empty slot
    
    def put(self, key, value):
        """Insert or update key-value pair"""
        index, probes, step = self._find_slot(key)
        
        if index is None:
            raise Exception("Hash table is full")
        
        # If this is a new key
        if self.keys[index] is None or self.deleted[index]:
            self.size += 1
        
        self.keys[index] = key
        self.values[index] = value
        self.deleted[index] = False
        
        return probes, step
    
    def get(self, key):
        """Retrieve value by key"""
        index, probes, step = self._find_slot(key)
        
        if index is None or self.keys[index] != key or self.deleted[index]:
            raise KeyError(f"Key '{key}' not found")
        
        return self.values[index], probes, step
    
    def display_structure(self):
        """Display internal structure with hash values"""
        print(f"Double Hashing Table (size: {self.size}, capacity: {self.capacity}):")
        print("Index | Key        | Value | Hash1 | Hash2 | Deleted")
        print("-" * 55)
        
        for i in range(self.capacity):
            key = self.keys[i] if self.keys[i] is not None else "None"
            value = self.values[i] if self.values[i] is not None else "None"
            deleted = "Yes" if self.deleted[i] else "No"
            
            if self.keys[i] is not None:
                hash1 = self._hash1(self.keys[i])
                hash2 = self._hash2(self.keys[i])
            else:
                hash1 = hash2 = "-"
            
            print(f"{i:5} | {str(key):10} | {str(value):5} | {str(hash1):5} | {str(hash2):5} | {deleted}")

# Demonstrate double hashing
def demonstrate_double_hashing():
    ht = HashTableDoubleHashing(11)
    
    items = [("apple", 1), ("banana", 2), ("cherry", 3), ("date", 4), 
             ("elderberry", 5), ("fig", 6)]
    
    print("Inserting items into hash table with double hashing:")
    for key, value in items:
        probes, step = ht.put(key, value)
        print(f"Inserted '{key}': {value} (probes: {probes}, step: {step})")
    
    print("\n" + "="*60)
    ht.display_structure()

demonstrate_double_hashing()
```

## Advanced Hash Table Implementations

### Robin Hood Hashing
```python
class RobinHoodHashTable:
    """Robin Hood hashing - minimizes variance in probe distances"""
    
    def __init__(self, initial_capacity=8):
        self.capacity = initial_capacity
        self.size = 0
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.distances = [0] * self.capacity  # Distance from ideal position
    
    def _hash(self, key):
        """Hash function"""
        return hash(key) % self.capacity
    
    def _probe_distance(self, index, key):
        """Calculate probe distance for a key at given index"""
        ideal_index = self._hash(key)
        return (index - ideal_index) % self.capacity
    
    def put(self, key, value):
        """Insert using Robin Hood hashing"""
        if self.size >= self.capacity * 0.7:  # Resize if load factor too high
            self._resize()
        
        index = self._hash(key)
        distance = 0
        
        while True:
            # Empty slot found
            if self.keys[index] is None:
                self.keys[index] = key
                self.values[index] = value
                self.distances[index] = distance
                self.size += 1
                break
            
            # Key already exists
            if self.keys[index] == key:
                self.values[index] = value
                break
            
            # Robin Hood: if current distance is greater than existing distance
            existing_distance = self.distances[index]
            if distance > existing_distance:
                # Swap current entry with existing
                self.keys[index], key = key, self.keys[index]
                self.values[index], value = value, self.values[index]
                self.distances[index], distance = distance, existing_distance
                self.size += 1  # Only increment if we displaced an existing entry
            
            index = (index + 1) % self.capacity
            distance += 1
    
    def get(self, key):
        """Retrieve value by key"""
        index = self._hash(key)
        distance = 0
        
        while self.keys[index] is not None:
            if self.keys[index] == key:
                return self.values[index]
            
            # If current distance exceeds the stored distance,
            # the key doesn't exist (Robin Hood property)
            if distance > self.distances[index]:
                break
            
            index = (index + 1) % self.capacity
            distance += 1
        
        raise KeyError(f"Key '{key}' not found")
    
    def _resize(self):
        """Resize the hash table"""
        old_keys, old_values = self.keys, self.values
        old_capacity = self.capacity
        
        self.capacity *= 2
        self.size = 0
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.distances = [0] * self.capacity
        
        for i in range(old_capacity):
            if old_keys[i] is not None:
                self.put(old_keys[i], old_values[i])
        
        print(f"Resized from {old_capacity} to {self.capacity}")
    
    def display_structure(self):
        """Display structure with distances"""
        print(f"Robin Hood Hash Table (size: {self.size}, capacity: {self.capacity}):")
        print("Index | Key        | Value | Distance")
        print("-" * 40)
        
        for i in range(self.capacity):
            key = self.keys[i] if self.keys[i] is not None else "None"
            value = self.values[i] if self.values[i] is not None else "None"
            distance = self.distances[i] if self.keys[i] is not None else "-"
            print(f"{i:5} | {str(key):10} | {str(value):5} | {str(distance):8}")
    
    def get_variance_statistics(self):
        """Calculate variance in probe distances"""
        distances = [self.distances[i] for i in range(self.capacity) if self.keys[i] is not None]
        
        if not distances:
            return {'mean': 0, 'variance': 0, 'max_distance': 0}
        
        mean = sum(distances) / len(distances)
        variance = sum((d - mean) ** 2 for d in distances) / len(distances)
        max_distance = max(distances)
        
        return {
            'mean': mean,
            'variance': variance,
            'max_distance': max_distance
        }

# Demonstrate Robin Hood hashing
def demonstrate_robin_hood():
    rh_table = RobinHoodHashTable(7)
    
    items = [("apple", 1), ("banana", 2), ("cherry", 3), ("date", 4), ("elderberry", 5)]
    
    print("Robin Hood Hashing Demo:")
    for key, value in items:
        rh_table.put(key, value)
        print(f"Inserted '{key}': {value}")
    
    print("\n" + "="*50)
    rh_table.display_structure()
    
    print("\nVariance Statistics:")
    stats = rh_table.get_variance_statistics()
    for key, value in stats.items():
        print(f"{key.replace('_', ' ').title()}: {value:.2f}")

demonstrate_robin_hood()
```

### Cuckoo Hashing
```python
class CuckooHashTable:
    """Cuckoo hashing with two hash functions and tables"""
    
    def __init__(self, initial_capacity=8):
        self.capacity = initial_capacity
        self.size = 0
        self.table1 = [None] * self.capacity
        self.table2 = [None] * self.capacity
        self.max_iterations = self.capacity  # Prevent infinite loops
    
    def _hash1(self, key):
        """First hash function"""
        return hash(key) % self.capacity
    
    def _hash2(self, key):
        """Second hash function"""
        # Use a different approach for second hash
        return (hash(str(key) + "salt") % self.capacity)
    
    def _rehash(self):
        """Rehash all elements into larger tables"""
        old_table1, old_table2 = self.table1, self.table2
        old_capacity = self.capacity
        
        self.capacity *= 2
        self.size = 0
        self.table1 = [None] * self.capacity
        self.table2 = [None] * self.capacity
        
        # Reinsert all elements
        for table in [old_table1, old_table2]:
            for item in table:
                if item is not None:
                    key, value = item
                    self.put(key, value)
        
        print(f"Rehashed from {old_capacity} to {self.capacity}")
    
    def put(self, key, value):
        """Insert key-value pair using cuckoo hashing"""
        # Check if key already exists
        if self.contains(key):
            # Update existing value
            index1 = self._hash1(key)
            index2 = self._hash2(key)
            
            if self.table1[index1] and self.table1[index1][0] == key:
                self.table1[index1] = (key, value)
            elif self.table2[index2] and self.table2[index2][0] == key:
                self.table2[index2] = (key, value)
            return
        
        item = (key, value)
        
        for iteration in range(self.max_iterations):
            # Try to place in table1
            index1 = self._hash1(item[0])
            if self.table1[index1] is None:
                self.table1[index1] = item
                self.size += 1
                return
            
            # Kick out existing item from table1
            displaced_item = self.table1[index1]
            self.table1[index1] = item
            item = displaced_item
            
            # Try to place displaced item in table2
            index2 = self._hash2(item[0])
            if self.table2[index2] is None:
                self.table2[index2] = item
                self.size += 1
                return
            
            # Kick out existing item from table2
            displaced_item = self.table2[index2]
            self.table2[index2] = item
            item = displaced_item
        
        # If we reach here, we have a cycle - need to rehash
        print(f"Cycle detected, rehashing...")
        self._rehash()
        self.put(key, value)  # Retry after rehashing
    
    def get(self, key):
        """Retrieve value by key"""
        index1 = self._hash1(key)
        if self.table1[index1] and self.table1[index1][0] == key:
            return self.table1[index1][1]
        
        index2 = self._hash2(key)
        if self.table2[index2] and self.table2[index2][0] == key:
            return self.table2[index2][1]
        
        raise KeyError(f"Key '{key}' not found")
    
    def contains(self, key):
        """Check if key exists"""
        try:
            self.get(key)
            return True
        except KeyError:
            return False
    
    def delete(self, key):
        """Remove key-value pair"""
        index1 = self._hash1(key)
        if self.table1[index1] and self.table1[index1][0] == key:
            value = self.table1[index1][1]
            self.table1[index1] = None
            self.size -= 1
            return value
        
        index2 = self._hash2(key)
        if self.table2[index2] and self.table2[index2][0] == key:
            value = self.table2[index2][1]
            self.table2[index2] = None
            self.size -= 1
            return value
        
        raise KeyError(f"Key '{key}' not found")
    
    def display_structure(self):
        """Display both tables"""
        print(f"Cuckoo Hash Table (size: {self.size}, capacity: {self.capacity}):")
        print("Table 1:")
        print("Index | Key-Value")
        print("-" * 25)
        for i, item in enumerate(self.table1):
            content = str(item) if item else "None"
            print(f"{i:5} | {content}")
        
        print("\nTable 2:")
        print("Index | Key-Value")
        print("-" * 25)
        for i, item in enumerate(self.table2):
            content = str(item) if item else "None"
            print(f"{i:5} | {content}")

# Demonstrate cuckoo hashing
def demonstrate_cuckoo_hashing():
    ch_table = CuckooHashTable(5)
    
    items = [("apple", 1), ("banana", 2), ("cherry", 3), ("date", 4)]
    
    print("Cuckoo Hashing Demo:")
    for key, value in items:
        ch_table.put(key, value)
        print(f"Inserted '{key}': {value}")
    
    print("\n" + "="*50)
    ch_table.display_structure()
    
    # Test retrieval
    print(f"\nTesting retrieval:")
    for key, _ in items:
        try:
            value = ch_table.get(key)
            print(f"'{key}': {value}")
        except KeyError as e:
            print(e)

demonstrate_cuckoo_hashing()
```

## Hash Table Applications and Algorithms

### Set Operations using Hash Tables
```python
class HashSet:
    """Set implementation using hash table"""
    
    def __init__(self):
        self.table = HashTableChaining()
    
    def add(self, item):
        """Add item to set"""
        self.table.put(item, True)
    
    def remove(self, item):
        """Remove item from set"""
        try:
            self.table.delete(item)
        except KeyError:
            raise KeyError(f"Item '{item}' not in set")
    
    def contains(self, item):
        """Check if item is in set"""
        return self.table.contains(item)
    
    def size(self):
        """Get number of items"""
        return self.table.size
    
    def to_list(self):
        """Convert to list"""
        return self.table.keys()
    
    def union(self, other_set):
        """Union with another set"""
        result = HashSet()
        for item in self.to_list():
            result.add(item)
        for item in other_set.to_list():
            result.add(item)
        return result
    
    def intersection(self, other_set):
        """Intersection with another set"""
        result = HashSet()
        for item in self.to_list():
            if other_set.contains(item):
                result.add(item)
        return result
    
    def difference(self, other_set):
        """Difference with another set"""
        result = HashSet()
        for item in self.to_list():
            if not other_set.contains(item):
                result.add(item)
        return result
    
    def symmetric_difference(self, other_set):
        """Symmetric difference with another set"""
        return self.union(other_set).difference(self.intersection(other_set))

def demonstrate_set_operations():
    set1 = HashSet()
    set2 = HashSet()
    
    # Add items to sets
    for item in [1, 2, 3, 4, 5]:
        set1.add(item)
    
    for item in [4, 5, 6, 7, 8]:
        set2.add(item)
    
    print("Set Operations Demo:")
    print(f"Set 1: {set1.to_list()}")
    print(f"Set 2: {set2.to_list()}")
    
    print(f"Union: {set1.union(set2).to_list()}")
    print(f"Intersection: {set1.intersection(set2).to_list()}")
    print(f"Difference (1-2): {set1.difference(set2).to_list()}")
    print(f"Symmetric Difference: {set1.symmetric_difference(set2).to_list()}")

demonstrate_set_operations()
```

### Frequency Counter and Top-K Elements
```python
from collections import defaultdict
import heapq

class FrequencyCounter:
    """Frequency counter using hash table"""
    
    def __init__(self):
        self.counts = defaultdict(int)
        self.total_items = 0
    
    def add(self, item, count=1):
        """Add item(s) to counter"""
        self.counts[item] += count
        self.total_items += count
    
    def get_count(self, item):
        """Get count for item"""
        return self.counts[item]
    
    def get_frequency(self, item):
        """Get frequency (proportion) for item"""
        if self.total_items == 0:
            return 0
        return self.counts[item] / self.total_items
    
    def most_common(self, k=None):
        """Get k most common items"""
        sorted_items = sorted(self.counts.items(), key=lambda x: x[1], reverse=True)
        return sorted_items[:k] if k else sorted_items
    
    def top_k_frequent(self, k):
        """Get top k frequent items using min-heap (efficient for large datasets)"""
        if k >= len(self.counts):
            return list(self.counts.keys())
        
        # Use min-heap to maintain top k elements
        heap = []
        
        for item, count in self.counts.items():
            if len(heap) < k:
                heapq.heappush(heap, (count, item))
            elif count > heap[0][0]:
                heapq.heapreplace(heap, (count, item))
        
        # Extract items from heap (in reverse order for descending frequency)
        result = []
        while heap:
            count, item = heapq.heappop(heap)
            result.append(item)
        
        return result[::-1]  # Reverse to get descending order
    
    def get_statistics(self):
        """Get statistical information"""
        if not self.counts:
            return {}
        
        counts = list(self.counts.values())
        return {
            'unique_items': len(self.counts),
            'total_items': self.total_items,
            'min_count': min(counts),
            'max_count': max(counts),
            'avg_count': sum(counts) / len(counts),
            'median_count': sorted(counts)[len(counts) // 2]
        }

def demonstrate_frequency_analysis():
    # Sample text analysis
    text = """
    The quick brown fox jumps over the lazy dog.
    The dog was lazy but the fox was quick.
    Brown foxes are quick and dogs can be lazy.
    """
    
    # Count word frequencies
    words = text.lower().replace('.', '').replace(',', '').split()
    
    counter = FrequencyCounter()
    for word in words:
        counter.add(word)
    
    print("Frequency Analysis Demo:")
    print(f"Text: {text.strip()}")
    print(f"\nTotal words: {counter.total_items}")
    print(f"Unique words: {len(counter.counts)}")
    
    print(f"\nAll word frequencies:")
    for word, count in counter.most_common():
        frequency = counter.get_frequency(word)
        print(f"'{word}': {count} ({frequency:.1%})")
    
    print(f"\nTop 3 most frequent words:")
    top_3 = counter.top_k_frequent(3)
    for word in top_3:
        count = counter.get_count(word)
        print(f"'{word}': {count}")
    
    print(f"\nStatistics:")
    stats = counter.get_statistics()
    for key, value in stats.items():
        print(f"{key.replace('_', ' ').title()}: {value:.2f}")

demonstrate_frequency_analysis()
```

### Cache Implementation (LRU Cache)
```python
class LRUCache:
    """Least Recently Used Cache using hash table + doubly linked list"""
    
    class Node:
        def __init__(self, key=None, value=None):
            self.key = key
            self.value = value
            self.prev = None
            self.next = None
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.size = 0
        self.cache = {}  # Hash table for O(1) access
        
        # Create dummy head and tail nodes
        self.head = self.Node()
        self.tail = self.Node()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_node(self, node):
        """Add node after head"""
        node.prev = self.head
        node.next = self.head.next
        
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node):
        """Remove node from list"""
        prev_node = node.prev
        next_node = node.next
        
        prev_node.next = next_node
        next_node.prev = prev_node
    
    def _move_to_head(self, node):
        """Move node to head (mark as recently used)"""
        self._remove_node(node)
        self._add_node(node)
    
    def _pop_tail(self):
        """Remove last node (least recently used)"""
        last_node = self.tail.prev
        self._remove_node(last_node)
        return last_node
    
    def get(self, key):
        """Get value and mark as recently used"""
        if key in self.cache:
            node = self.cache[key]
            # Move to head (mark as recently used)
            self._move_to_head(node)
            return node.value
        else:
            return -1
    
    def put(self, key, value):
        """Put key-value pair"""
        if key in self.cache:
            # Update existing
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            # Add new
            new_node = self.Node(key, value)
            
            if self.size < self.capacity:
                # Space available
                self.cache[key] = new_node
                self._add_node(new_node)
                self.size += 1
            else:
                # Remove LRU item
                tail_node = self._pop_tail()
                del self.cache[tail_node.key]
                
                # Add new item
                self.cache[key] = new_node
                self._add_node(new_node)
    
    def display_cache(self):
        """Display current cache state"""
        print(f"LRU Cache (capacity: {self.capacity}, size: {self.size}):")
        print("From most recent to least recent:")
        
        current = self.head.next
        items = []
        while current != self.tail:
            items.append(f"({current.key}: {current.value})")
            current = current.next
        
        print(" -> ".join(items))
    
    def get_access_pattern(self):
        """Get current access pattern"""
        pattern = []
        current = self.head.next
        while current != self.tail:
            pattern.append(current.key)
            current = current.next
        return pattern

def demonstrate_lru_cache():
    cache = LRUCache(3)
    
    print("LRU Cache Demo:")
    
    # Test operations
    operations = [
        ("put", 1, 10),
        ("put", 2, 20),
        ("put", 3, 30),
        ("get", 2, None),
        ("put", 4, 40),  # Should evict key 1
        ("get", 1, None),  # Should return -1
        ("get", 3, None),
        ("get", 4, None),
        ("put", 5, 50),  # Should evict key 2
    ]
    
    for i, op in enumerate(operations):
        if op[0] == "put":
            print(f"\nStep {i+1}: Put({op[1]}, {op[2]})")
            cache.put(op[1], op[2])
        else:
            print(f"\nStep {i+1}: Get({op[1]})")
            result = cache.get(op[1])
            print(f"Returned: {result}")
        
        cache.display_cache()
        print(f"Access pattern: {cache.get_access_pattern()}")

demonstrate_lru_cache()
```

### String Anagram Grouping
```python
def group_anagrams_hash():
    """Group anagrams using hash tables"""
    
    def group_anagrams_sorting(strs):
        """Group anagrams by sorting characters"""
        groups = defaultdict(list)
        
        for s in strs:
            # Sort characters to create key
            key = ''.join(sorted(s))
            groups[key].append(s)
        
        return list(groups.values())
    
    def group_anagrams_counting(strs):
        """Group anagrams by character counting"""
        groups = defaultdict(list)
        
        for s in strs:
            # Create character count signature
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            
            # Convert to tuple for hashing
            key = tuple(count)
            groups[key].append(s)
        
        return list(groups.values())
    
    def group_anagrams_prime(strs):
        """Group anagrams using prime number multiplication"""
        # Prime numbers for each letter
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]
        
        groups = defaultdict(list)
        
        for s in strs:
            # Calculate prime product
            key = 1
            for c in s:
                key *= primes[ord(c) - ord('a')]
            
            groups[key].append(s)
        
        return list(groups.values())
    
    # Test different approaches
    test_strings = ["eat", "tea", "tan", "ate", "nat", "bat", "tab"]
    
    print("Anagram Grouping Demo:")
    print(f"Input strings: {test_strings}")
    
    methods = [
        ("Sorting approach", group_anagrams_sorting),
        ("Counting approach", group_anagrams_counting),
        ("Prime multiplication", group_anagrams_prime)
    ]
    
    for name, method in methods:
        result = method(test_strings)
        print(f"\n{name}:")
        for i, group in enumerate(result):
            print(f"  Group {i+1}: {group}")

group_anagrams_hash()
```

## Hash Table Performance Analysis

### Performance Comparison
```python
import time
import random

def hash_table_performance_analysis():
    """Compare performance of different hash table implementations"""
    
    def time_operations(hash_table, operations):
        """Time a series of operations"""
        start_time = time.time()
        
        for op, key, value in operations:
            try:
                if op == "put":
                    hash_table.put(key, value)
                elif op == "get":
                    hash_table.get(key)
                elif op == "delete":
                    hash_table.delete(key)
            except:
                pass  # Ignore errors for timing purposes
        
        return time.time() - start_time
    
    # Generate test data
    def generate_operations(size):
        operations = []
        keys = list(range(size))
        random.shuffle(keys)
        
        # Insert operations
        for i, key in enumerate(keys):
            operations.append(("put", key, i))
        
        # Random access operations
        for _ in range(size // 2):
            key = random.choice(keys)
            operations.append(("get", key, None))
        
        # Delete operations
        for key in keys[:size // 4]:
            operations.append(("delete", key, None))
        
        return operations
    
    # Test different sizes
    sizes = [100, 1000, 5000]
    
    print("Hash Table Performance Analysis:")
    print("=" * 60)
    
    for size in sizes:
        print(f"\nTesting with {size} operations:")
        operations = generate_operations(size)
        
        # Test different implementations
        implementations = [
            ("Chaining", lambda: HashTableChaining(size // 4)),
            ("Open Addressing", lambda: HashTableOpenAddressing(size // 4)),
            ("Python dict", lambda: {})
        ]
        
        results = {}
        
        for name, create_table in implementations:
            table = create_table()
            
            if name == "Python dict":
                # Special handling for Python dict
                start_time = time.time()
                for op, key, value in operations:
                    try:
                        if op == "put":
                            table[key] = value
                        elif op == "get":
                            _ = table[key]
                        elif op == "delete":
                            del table[key]
                    except:
                        pass
                elapsed = time.time() - start_time
            else:
                elapsed = time_operations(table, operations)
            
            results[name] = elapsed
        
        # Display results
        print("Implementation      | Time (seconds)")
        print("-" * 40)
        for name, time_taken in results.items():
            print(f"{name:18} | {time_taken:.6f}")
        
        # Calculate speedup relative to chaining
        if "Chaining" in results:
            baseline = results["Chaining"]
            print(f"\nSpeedup relative to chaining:")
            for name, time_taken in results.items():
                if name != "Chaining":
                    speedup = baseline / time_taken
                    print(f"{name:18}: {speedup:.2f}x")

hash_table_performance_analysis()
```

### Load Factor Analysis
```python
def load_factor_analysis():
    """Analyze how load factor affects performance"""
    
    def measure_performance_at_load_factor(load_factor, table_size=1000):
        """Measure performance at specific load factor"""
        num_elements = int(table_size * load_factor)
        
        # Test chaining
        ht_chain = HashTableChaining(table_size)
        
        # Insert elements
        insert_time = 0
        for i in range(num_elements):
            start = time.time()
            ht_chain.put(f"key_{i}", i)
            insert_time += time.time() - start
        
        # Test retrieval
        lookup_time = 0
        for i in range(min(100, num_elements)):  # Test 100 lookups
            key = f"key_{random.randint(0, num_elements-1)}"
            start = time.time()
            try:
                ht_chain.get(key)
            except:
                pass
            lookup_time += time.time() - start
        
        # Get statistics
        stats = ht_chain.get_statistics()
        
        return {
            'load_factor': load_factor,
            'avg_insert_time': insert_time / num_elements,
            'avg_lookup_time': lookup_time / 100,
            'max_chain_length': stats['max_chain_length'],
            'avg_chain_length': stats['avg_chain_length']
        }
    
    # Test different load factors
    load_factors = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0]
    
    print("Load Factor Performance Analysis:")
    print("=" * 80)
    print("Load   | Avg Insert | Avg Lookup | Max Chain | Avg Chain")
    print("Factor | Time (μs)  | Time (μs)  | Length    | Length")
    print("-" * 80)
    
    for lf in load_factors:
        result = measure_performance_at_load_factor(lf)
        
        print(f"{result['load_factor']:6.2f} | "
              f"{result['avg_insert_time']*1000000:10.2f} | "
              f"{result['avg_lookup_time']*1000000:10.2f} | "
              f"{result['max_chain_length']:9.0f} | "
              f"{result['avg_chain_length']:9.2f}")

load_factor_analysis()
```

## Summary

Hash tables are fundamental data structures with excellent performance characteristics:

### Key Benefits:
1. **Fast Operations**: Average O(1) time for insert, search, delete
2. **Flexible Keys**: Can use any hashable type as keys
3. **Dynamic Sizing**: Can grow and shrink as needed
4. **Memory Efficient**: Good space utilization with proper load factors

### Collision Resolution Strategies:
- **Separate Chaining**: Simple, handles high load factors well
- **Open Addressing**: Better cache performance, requires careful deletion
- **Robin Hood Hashing**: Minimizes variance in probe distances
- **Cuckoo Hashing**: Guarantees O(1) worst-case lookup time

### Important Considerations:
- **Hash Function Quality**: Determines distribution and performance
- **Load Factor**: Balance between space and time efficiency
- **Collision Handling**: Choose strategy based on use case
- **Resizing Strategy**: When and how to grow/shrink the table

### Applications:
- **Databases**: Indexing and quick lookups
- **Caching**: LRU cache, memoization
- **Sets and Maps**: Implementing associative data structures
- **Algorithms**: Two-sum, anagram detection, frequency counting
- **System Design**: Distributed hashing, consistent hashing

Understanding hash tables deeply enables efficient data storage, fast lookups, and solving complex algorithmic problems in competitive programming and real-world applications.