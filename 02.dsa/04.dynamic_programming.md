# Dynamic Programming - Algorithmic Fundamentals

## What is Dynamic Programming?

**Dynamic Programming (DP)** is an algorithmic paradigm that solves complex problems by breaking them down into simpler subproblems and storing the results of subproblems to avoid computing the same results again.

### Key Characteristics:
- **Optimal Substructure**: Optimal solution contains optimal solutions to subproblems
- **Overlapping Subproblems**: Same subproblems are solved multiple times
- **Memoization**: Store results to avoid recomputation
- **Bottom-up or Top-down**: Can be implemented recursively or iteratively
- **Time-Space Tradeoff**: Uses extra space to save time

```python
# Simple example: Computing Fibonacci numbers
# Without DP: F(n) = F(n-1) + F(n-2) - O(2^n) time
# With DP: Store computed values - O(n) time, O(n) space

def fibonacci_naive(n):
    """Naive recursive approach - exponential time"""
    if n <= 1:
        return n
    return fibonacci_naive(n-1) + fibonacci_naive(n-2)

def fibonacci_dp(n):
    """Dynamic programming approach - linear time"""
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# Comparison
import time

def compare_fibonacci_approaches():
    print("Fibonacci Computation Comparison:")
    print("n  | Naive Time | DP Time   | Speedup")
    print("-" * 40)
    
    for n in [10, 20, 30, 35]:
        # Time naive approach
        start = time.time()
        naive_result = fibonacci_naive(n)
        naive_time = time.time() - start
        
        # Time DP approach
        start = time.time()
        dp_result = fibonacci_dp(n)
        dp_time = time.time() - start
        
        speedup = naive_time / dp_time if dp_time > 0 else float('inf')
        
        print(f"{n:2} | {naive_time:9.6f} | {dp_time:8.6f} | {speedup:6.0f}x")

compare_fibonacci_approaches()
```

## How Dynamic Programming Works

### The DP Process
```python
def dp_problem_analysis():
    """Analyze the structure of DP problems"""
    
    print("Dynamic Programming Problem Structure:")
    print("=" * 50)
    
    print("\n1. IDENTIFY OPTIMAL SUBSTRUCTURE:")
    print("   - Can the optimal solution be constructed from optimal solutions of subproblems?")
    print("   - Example: Shortest path - if A->C is shortest, then A->B->C means A->B is also shortest")
    
    print("\n2. FIND OVERLAPPING SUBPROBLEMS:")
    print("   - Are the same subproblems solved multiple times?")
    print("   - Example: Fibonacci F(5) = F(4) + F(3), F(4) = F(3) + F(2)")
    print("   - F(3) is computed twice!")
    
    print("\n3. DEFINE STATE:")
    print("   - What parameters uniquely identify each subproblem?")
    print("   - Example: F(n) - state is just 'n'")
    print("   - Example: LCS(i,j) - state is position in both strings")
    
    print("\n4. DERIVE RECURRENCE RELATION:")
    print("   - How to express solution in terms of smaller subproblems?")
    print("   - Example: F(n) = F(n-1) + F(n-2)")
    
    print("\n5. DETERMINE BASE CASES:")
    print("   - What are the simplest subproblems we can solve directly?")
    print("   - Example: F(0) = 0, F(1) = 1")
    
    print("\n6. CHOOSE IMPLEMENTATION:")
    print("   - Top-down (Memoization): Recursive with caching")
    print("   - Bottom-up (Tabulation): Iterative table filling")

dp_problem_analysis()
```

### Memoization vs Tabulation
```python
def demonstrate_dp_approaches():
    """Compare top-down vs bottom-up DP approaches"""
    
    # Problem: Count number of ways to climb n stairs (1 or 2 steps at a time)
    
    def climb_stairs_memoization(n, memo=None):
        """Top-down approach with memoization"""
        if memo is None:
            memo = {}
        
        if n in memo:
            return memo[n]
        
        if n <= 2:
            return n
        
        memo[n] = climb_stairs_memoization(n-1, memo) + climb_stairs_memoization(n-2, memo)
        return memo[n]
    
    def climb_stairs_tabulation(n):
        """Bottom-up approach with tabulation"""
        if n <= 2:
            return n
        
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        
        for i in range(3, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        
        return dp[n]
    
    def climb_stairs_optimized(n):
        """Space-optimized bottom-up approach"""
        if n <= 2:
            return n
        
        prev2 = 1  # dp[i-2]
        prev1 = 2  # dp[i-1]
        
        for i in range(3, n + 1):
            current = prev1 + prev2
            prev2 = prev1
            prev1 = current
        
        return prev1
    
    # Test and compare
    test_values = [5, 10, 20, 30]
    
    print("Stair Climbing Problem - Different DP Approaches:")
    print("n  | Memoization | Tabulation | Optimized | Memory Usage")
    print("-" * 60)
    
    for n in test_values:
        memo_result = climb_stairs_memoization(n)
        tab_result = climb_stairs_tabulation(n)
        opt_result = climb_stairs_optimized(n)
        
        print(f"{n:2} | {memo_result:11} | {tab_result:10} | {opt_result:9} | O(n), O(n), O(1)")
    
    # Demonstrate call stack for memoization
    def climb_with_trace(n, memo=None, depth=0):
        """Memoized version with execution trace"""
        if memo is None:
            memo = {}
        
        indent = "  " * depth
        print(f"{indent}Computing stairs({n})")
        
        if n in memo:
            print(f"{indent}Found in memo: {memo[n]}")
            return memo[n]
        
        if n <= 2:
            print(f"{indent}Base case: {n}")
            return n
        
        result = climb_with_trace(n-1, memo, depth+1) + climb_with_trace(n-2, memo, depth+1)
        memo[n] = result
        print(f"{indent}Stored stairs({n}) = {result}")
        return result
    
    print(f"\nExecution trace for stairs(5):")
    result = climb_with_trace(5)
    print(f"Final result: {result}")

demonstrate_dp_approaches()
```

## Classic Dynamic Programming Problems

### 1. Longest Common Subsequence (LCS)
```python
def longest_common_subsequence():
    """Solve LCS problem with detailed explanation"""
    
    def lcs_length(text1, text2):
        """Find length of LCS using 2D DP table"""
        m, n = len(text1), len(text2)
        
        # Create DP table
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Fill the table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        return dp[m][n], dp
    
    def reconstruct_lcs(text1, text2, dp):
        """Reconstruct the actual LCS string"""
        m, n = len(text1), len(text2)
        lcs = []
        
        i, j = m, n
        while i > 0 and j > 0:
            if text1[i-1] == text2[j-1]:
                lcs.append(text1[i-1])
                i -= 1
                j -= 1
            elif dp[i-1][j] > dp[i][j-1]:
                i -= 1
            else:
                j -= 1
        
        return ''.join(reversed(lcs))
    
    def print_dp_table(text1, text2, dp):
        """Visualize the DP table"""
        m, n = len(text1), len(text2)
        
        print("DP Table for LCS:")
        print("    ", end="")
        for char in " " + text2:
            print(f"{char:3}", end="")
        print()
        
        for i in range(m + 1):
            char = " " if i == 0 else text1[i-1]
            print(f"{char:2} ", end="")
            for j in range(n + 1):
                print(f"{dp[i][j]:3}", end="")
            print()
    
    # Test LCS
    text1 = "ABCDGH"
    text2 = "AEDFHR"
    
    print("Longest Common Subsequence Problem:")
    print(f"Text 1: {text1}")
    print(f"Text 2: {text2}")
    
    length, dp_table = lcs_length(text1, text2)
    lcs_string = reconstruct_lcs(text1, text2, dp_table)
    
    print(f"\nLCS Length: {length}")
    print(f"LCS String: {lcs_string}")
    
    print()
    print_dp_table(text1, text2, dp_table)
    
    # Space-optimized version
    def lcs_space_optimized(text1, text2):
        """Space-optimized LCS using only O(min(m,n)) space"""
        m, n = len(text1), len(text2)
        
        # Ensure text1 is the shorter string
        if m > n:
            text1, text2 = text2, text1
            m, n = n, m
        
        # Use only two rows
        prev = [0] * (m + 1)
        curr = [0] * (m + 1)
        
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if text2[i-1] == text1[j-1]:
                    curr[j] = prev[j-1] + 1
                else:
                    curr[j] = max(prev[j], curr[j-1])
            
            prev, curr = curr, prev
        
        return prev[m]
    
    space_opt_result = lcs_space_optimized(text1, text2)
    print(f"\nSpace-optimized LCS length: {space_opt_result}")
    print(f"Space complexity: O(min(m,n)) instead of O(m*n)")

longest_common_subsequence()
```

### 2. 0/1 Knapsack Problem
```python
def knapsack_problem():
    """Solve 0/1 Knapsack problem with different approaches"""
    
    def knapsack_recursive(weights, values, capacity, n):
        """Naive recursive solution"""
        if n == 0 or capacity == 0:
            return 0
        
        # If weight of nth item is more than capacity, can't include it
        if weights[n-1] > capacity:
            return knapsack_recursive(weights, values, capacity, n-1)
        
        # Return max of including or excluding nth item
        include = values[n-1] + knapsack_recursive(weights, values, capacity - weights[n-1], n-1)
        exclude = knapsack_recursive(weights, values, capacity, n-1)
        
        return max(include, exclude)
    
    def knapsack_memoization(weights, values, capacity, n, memo=None):
        """Memoized recursive solution"""
        if memo is None:
            memo = {}
        
        if (n, capacity) in memo:
            return memo[(n, capacity)]
        
        if n == 0 or capacity == 0:
            return 0
        
        if weights[n-1] > capacity:
            result = knapsack_memoization(weights, values, capacity, n-1, memo)
        else:
            include = values[n-1] + knapsack_memoization(weights, values, capacity - weights[n-1], n-1, memo)
            exclude = knapsack_memoization(weights, values, capacity, n-1, memo)
            result = max(include, exclude)
        
        memo[(n, capacity)] = result
        return result
    
    def knapsack_dp(weights, values, capacity):
        """Bottom-up DP solution with item tracking"""
        n = len(weights)
        
        # Create DP table
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]
        
        # Fill the table
        for i in range(1, n + 1):
            for w in range(1, capacity + 1):
                if weights[i-1] <= w:
                    include = values[i-1] + dp[i-1][w - weights[i-1]]
                    exclude = dp[i-1][w]
                    dp[i][w] = max(include, exclude)
                else:
                    dp[i][w] = dp[i-1][w]
        
        return dp[n][capacity], dp
    
    def find_selected_items(weights, values, dp, capacity):
        """Find which items were selected"""
        n = len(weights)
        selected = []
        w = capacity
        
        for i in range(n, 0, -1):
            # If value comes from including current item
            if dp[i][w] != dp[i-1][w]:
                selected.append(i-1)  # 0-indexed item
                w -= weights[i-1]
        
        return list(reversed(selected))
    
    def print_knapsack_table(weights, values, dp, capacity):
        """Visualize the DP table"""
        n = len(weights)
        
        print("Knapsack DP Table:")
        print("Item\\Cap", end="")
        for c in range(capacity + 1):
            print(f"{c:4}", end="")
        print()
        
        for i in range(n + 1):
            if i == 0:
                print(f"{'':8}", end="")
            else:
                print(f"I{i}(w{weights[i-1]})", end="")
            
            for c in range(capacity + 1):
                print(f"{dp[i][c]:4}", end="")
            print()
    
    # Test data
    weights = [1, 3, 4, 5]
    values = [1, 4, 5, 7]
    capacity = 7
    n = len(weights)
    
    print("0/1 Knapsack Problem:")
    print(f"Items: {[(f'w{weights[i]}, v{values[i]}') for i in range(n)]}")
    print(f"Capacity: {capacity}")
    
    # Compare approaches
    import time
    
    # Recursive (only for small inputs)
    if n <= 10:
        start = time.time()
        recursive_result = knapsack_recursive(weights, values, capacity, n)
        recursive_time = time.time() - start
        print(f"\nRecursive result: {recursive_result} (time: {recursive_time:.6f}s)")
    
    # Memoization
    start = time.time()
    memo_result = knapsack_memoization(weights, values, capacity, n)
    memo_time = time.time() - start
    print(f"Memoization result: {memo_result} (time: {memo_time:.6f}s)")
    
    # DP
    start = time.time()
    dp_result, dp_table = knapsack_dp(weights, values, capacity)
    dp_time = time.time() - start
    print(f"DP result: {dp_result} (time: {dp_time:.6f}s)")
    
    # Find selected items
    selected = find_selected_items(weights, values, dp_table, capacity)
    print(f"\nSelected items (0-indexed): {selected}")
    print("Selected items details:")
    total_weight = 0
    total_value = 0
    for i in selected:
        print(f"  Item {i}: weight={weights[i]}, value={values[i]}")
        total_weight += weights[i]
        total_value += values[i]
    print(f"Total weight: {total_weight}, Total value: {total_value}")
    
    print()
    print_knapsack_table(weights, values, dp_table, capacity)
    
    # Space-optimized version
    def knapsack_space_optimized(weights, values, capacity):
        """Space-optimized knapsack using O(capacity) space"""
        n = len(weights)
        dp = [0] * (capacity + 1)
        
        for i in range(n):
            # Traverse backwards to avoid using updated values
            for w in range(capacity, weights[i] - 1, -1):
                dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
        
        return dp[capacity]
    
    space_opt_result = knapsack_space_optimized(weights, values, capacity)
    print(f"\nSpace-optimized result: {space_opt_result}")
    print(f"Space complexity: O(capacity) instead of O(n * capacity)")

knapsack_problem()
```

### 3. Longest Increasing Subsequence (LIS)
```python
def longest_increasing_subsequence():
    """Solve LIS problem with multiple approaches"""
    
    def lis_dp_n2(arr):
        """O(n²) DP solution"""
        n = len(arr)
        if n == 0:
            return 0, []
        
        # dp[i] = length of LIS ending at index i
        dp = [1] * n
        parent = [-1] * n  # To reconstruct the sequence
        
        for i in range(1, n):
            for j in range(i):
                if arr[j] < arr[i] and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    parent[i] = j
        
        # Find the index with maximum LIS length
        max_length = max(dp)
        max_index = dp.index(max_length)
        
        # Reconstruct the LIS
        lis = []
        current = max_index
        while current != -1:
            lis.append(arr[current])
            current = parent[current]
        
        return max_length, list(reversed(lis)), dp
    
    def lis_binary_search(arr):
        """O(n log n) solution using binary search"""
        n = len(arr)
        if n == 0:
            return 0, []
        
        # tails[i] = smallest ending element of all increasing subsequences of length i+1
        tails = []
        parent = [-1] * n
        tail_indices = []  # Track indices for reconstruction
        
        def binary_search(target):
            """Find position to insert target"""
            left, right = 0, len(tails)
            while left < right:
                mid = (left + right) // 2
                if tails[mid] < target:
                    left = mid + 1
                else:
                    right = mid
            return left
        
        for i, num in enumerate(arr):
            pos = binary_search(num)
            
            if pos == len(tails):
                tails.append(num)
                tail_indices.append(i)
            else:
                tails[pos] = num
                tail_indices[pos] = i
            
            # Set parent for reconstruction
            if pos > 0:
                parent[i] = tail_indices[pos - 1]
        
        # Reconstruct LIS
        lis = []
        current = tail_indices[-1] if tail_indices else -1
        while current != -1:
            lis.append(arr[current])
            current = parent[current]
        
        return len(tails), list(reversed(lis))
    
    def print_lis_table(arr, dp):
        """Visualize the DP computation"""
        print("LIS DP Table:")
        print("Index:", " ".join(f"{i:3}" for i in range(len(arr))))
        print("Value:", " ".join(f"{arr[i]:3}" for i in range(len(arr))))
        print("LIS  :", " ".join(f"{dp[i]:3}" for i in range(len(arr))))
    
    # Test LIS
    test_arrays = [
        [10, 9, 2, 5, 3, 7, 101, 18],
        [0, 1, 0, 3, 2, 3],
        [7, 7, 7, 7, 7, 7, 7]
    ]
    
    for i, arr in enumerate(test_arrays):
        print(f"Test {i+1}: {arr}")
        
        # O(n²) solution
        length_n2, lis_n2, dp = lis_dp_n2(arr)
        print(f"O(n²) solution:")
        print(f"  LIS length: {length_n2}")
        print(f"  LIS sequence: {lis_n2}")
        print_lis_table(arr, dp)
        
        # O(n log n) solution
        length_nlogn, lis_nlogn = lis_binary_search(arr)
        print(f"O(n log n) solution:")
        print(f"  LIS length: {length_nlogn}")
        print(f"  LIS sequence: {lis_nlogn}")
        
        print("-" * 50)
    
    # Performance comparison
    def compare_lis_performance():
        import random
        import time
        
        print("Performance Comparison:")
        print("Size  | O(n²) Time | O(n log n) Time | Speedup")
        print("-" * 50)
        
        for size in [100, 500, 1000, 2000]:
            # Generate random array
            arr = [random.randint(1, size) for _ in range(size)]
            
            # Time O(n²) solution
            start = time.time()
            length_n2, _ = lis_dp_n2(arr)[:2]
            time_n2 = time.time() - start
            
            # Time O(n log n) solution
            start = time.time()
            length_nlogn, _ = lis_binary_search(arr)
            time_nlogn = time.time() - start
            
            speedup = time_n2 / time_nlogn if time_nlogn > 0 else float('inf')
            
            print(f"{size:4} | {time_n2:10.6f} | {time_nlogn:14.6f} | {speedup:6.1f}x")
    
    compare_lis_performance()

longest_increasing_subsequence()
```

### 4. Edit Distance (Levenshtein Distance)
```python
def edit_distance_problem():
    """Solve edit distance problem with operation tracking"""
    
    def edit_distance_dp(str1, str2):
        """Compute edit distance with operation tracking"""
        m, n = len(str1), len(str2)
        
        # Create DP table
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # Initialize base cases
        for i in range(m + 1):
            dp[i][0] = i  # Delete all characters from str1
        for j in range(n + 1):
            dp[0][j] = j  # Insert all characters to get str2
        
        # Fill the table
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if str1[i-1] == str2[j-1]:
                    dp[i][j] = dp[i-1][j-1]  # No operation needed
                else:
                    dp[i][j] = 1 + min(
                        dp[i-1][j],      # Delete
                        dp[i][j-1],      # Insert
                        dp[i-1][j-1]     # Replace
                    )
        
        return dp[m][n], dp
    
    def get_edit_operations(str1, str2, dp):
        """Reconstruct the sequence of edit operations"""
        m, n = len(str1), len(str2)
        operations = []
        
        i, j = m, n
        while i > 0 or j > 0:
            if i > 0 and j > 0 and str1[i-1] == str2[j-1]:
                # Characters match, no operation
                i -= 1
                j -= 1
            elif i > 0 and j > 0 and dp[i][j] == dp[i-1][j-1] + 1:
                # Replace operation
                operations.append(f"Replace '{str1[i-1]}' with '{str2[j-1]}' at position {i-1}")
                i -= 1
                j -= 1
            elif i > 0 and dp[i][j] == dp[i-1][j] + 1:
                # Delete operation
                operations.append(f"Delete '{str1[i-1]}' at position {i-1}")
                i -= 1
            elif j > 0 and dp[i][j] == dp[i][j-1] + 1:
                # Insert operation
                operations.append(f"Insert '{str2[j-1]}' at position {i}")
                j -= 1
        
        return list(reversed(operations))
    
    def print_edit_table(str1, str2, dp):
        """Visualize the edit distance DP table"""
        m, n = len(str1), len(str2)
        
        print("Edit Distance DP Table:")
        print("     ", end="")
        for char in " " + str2:
            print(f"{char:3}", end="")
        print()
        
        for i in range(m + 1):
            char = " " if i == 0 else str1[i-1]
            print(f"{char:2} ", end="")
            for j in range(n + 1):
                print(f"{dp[i][j]:3}", end="")
            print()
    
    def edit_distance_space_optimized(str1, str2):
        """Space-optimized version using O(min(m,n)) space"""
        m, n = len(str1), len(str2)
        
        # Ensure str1 is the shorter string
        if m > n:
            str1, str2 = str2, str1
            m, n = n, m
        
        # Use only two rows
        prev = list(range(m + 1))
        curr = [0] * (m + 1)
        
        for i in range(1, n + 1):
            curr[0] = i
            for j in range(1, m + 1):
                if str2[i-1] == str1[j-1]:
                    curr[j] = prev[j-1]
                else:
                    curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])
            
            prev, curr = curr, prev
        
        return prev[m]
    
    # Test edit distance
    test_cases = [
        ("kitten", "sitting"),
        ("saturday", "sunday"),
        ("intention", "execution"),
        ("horse", "ros")
    ]
    
    for str1, str2 in test_cases:
        print(f"Edit Distance: '{str1}' -> '{str2}'")
        
        distance, dp_table = edit_distance_dp(str1, str2)
        operations = get_edit_operations(str1, str2, dp_table)
        
        print(f"Minimum edit distance: {distance}")
        print("Operations needed:")
        for op in operations:
            print(f"  {op}")
        
        print()
        print_edit_table(str1, str2, dp_table)
        
        # Verify space-optimized version
        space_opt_distance = edit_distance_space_optimized(str1, str2)
        print(f"Space-optimized result: {space_opt_distance}")
        print(f"Results match: {distance == space_opt_distance}")
        print("-" * 60)

edit_distance_problem()
```

## Advanced Dynamic Programming Patterns

### 1. Interval DP
```python
def interval_dp_problems():
    """Demonstrate interval DP pattern"""
    
    def matrix_chain_multiplication(dimensions):
        """Find minimum cost to multiply chain of matrices"""
        n = len(dimensions) - 1  # Number of matrices
        
        # dp[i][j] = minimum cost to multiply matrices from i to j
        dp = [[0] * n for _ in range(n)]
        split = [[0] * n for _ in range(n)]  # Track optimal split points
        
        # Length is the chain length
        for length in range(2, n + 1):  # Length of chain
            for i in range(n - length + 1):
                j = i + length - 1
                dp[i][j] = float('inf')
                
                # Try all possible split points
                for k in range(i, j):
                    cost = (dp[i][k] + dp[k+1][j] + 
                           dimensions[i] * dimensions[k+1] * dimensions[j+1])
                    
                    if cost < dp[i][j]:
                        dp[i][j] = cost
                        split[i][j] = k
        
        return dp[0][n-1], split
    
    def print_optimal_parentheses(split, i, j, matrices):
        """Print optimal parenthesization"""
        if i == j:
            return f"M{i}"
        else:
            k = split[i][j]
            left = print_optimal_parentheses(split, i, k, matrices)
            right = print_optimal_parentheses(split, k+1, j, matrices)
            return f"({left} × {right})"
    
    def palindrome_partitioning(s):
        """Find minimum cuts needed to partition string into palindromes"""
        n = len(s)
        
        # is_palindrome[i][j] = True if s[i:j+1] is palindrome
        is_palindrome = [[False] * n for _ in range(n)]
        
        # Every single character is palindrome
        for i in range(n):
            is_palindrome[i][i] = True
        
        # Check for palindromes of length 2
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                is_palindrome[i][i + 1] = True
        
        # Check for palindromes of length 3 and more
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j] and is_palindrome[i + 1][j - 1]:
                    is_palindrome[i][j] = True
        
        # dp[i] = minimum cuts needed for s[0:i+1]
        dp = [0] * n
        
        for i in range(n):
            if is_palindrome[0][i]:
                dp[i] = 0
            else:
                dp[i] = float('inf')
                for j in range(i):
                    if is_palindrome[j + 1][i]:
                        dp[i] = min(dp[i], dp[j] + 1)
        
        return dp[n - 1]
    
    # Test matrix chain multiplication
    print("Matrix Chain Multiplication:")
    dimensions = [40, 20, 30, 10, 30]  # 4 matrices: 40x20, 20x30, 30x10, 10x30
    matrices = [f"M{i}({dimensions[i]}×{dimensions[i+1]})" for i in range(len(dimensions)-1)]
    
    print(f"Matrices: {matrices}")
    min_cost, split_points = matrix_chain_multiplication(dimensions)
    optimal_parentheses = print_optimal_parentheses(split_points, 0, len(dimensions)-2, matrices)
    
    print(f"Minimum multiplication cost: {min_cost}")
    print(f"Optimal parenthesization: {optimal_parentheses}")
    
    # Test palindrome partitioning
    print(f"\nPalindrome Partitioning:")
    test_strings = ["aab", "raceacar", "abcde"]
    
    for s in test_strings:
        min_cuts = palindrome_partitioning(s)
        print(f"String: '{s}' -> Minimum cuts: {min_cuts}")

interval_dp_problems()
```

### 2. Digit DP
```python
def digit_dp_problems():
    """Demonstrate digit DP pattern"""
    
    def count_numbers_with_digit_sum(n, target_sum):
        """Count numbers <= n with digit sum equal to target_sum"""
        s = str(n)
        length = len(s)
        
        # Memoization: (position, current_sum, tight_constraint, started)
        memo = {}
        
        def dp(pos, curr_sum, tight, started):
            # Base case
            if pos == length:
                return 1 if curr_sum == target_sum and started else 0
            
            if (pos, curr_sum, tight, started) in memo:
                return memo[(pos, curr_sum, tight, started)]
            
            # If current sum already exceeds target, no valid numbers
            if curr_sum > target_sum:
                return 0
            
            limit = int(s[pos]) if tight else 9
            result = 0
            
            for digit in range(0, limit + 1):
                new_tight = tight and (digit == limit)
                new_started = started or (digit > 0)
                new_sum = curr_sum + digit if new_started else curr_sum
                
                result += dp(pos + 1, new_sum, new_tight, new_started)
            
            memo[(pos, curr_sum, tight, started)] = result
            return result
        
        return dp(0, 0, True, False)
    
    def count_numbers_without_consecutive_ones(n):
        """Count numbers <= n without consecutive 1s in binary representation"""
        if n <= 0:
            return 1
        
        binary = bin(n)[2:]  # Remove '0b' prefix
        length = len(binary)
        
        memo = {}
        
        def dp(pos, prev_bit, tight, started):
            if pos == length:
                return 1 if started else 0
            
            if (pos, prev_bit, tight, started) in memo:
                return memo[(pos, prev_bit, tight, started)]
            
            limit = int(binary[pos]) if tight else 1
            result = 0
            
            for bit in range(0, limit + 1):
                # Skip if placing 1 after 1 (consecutive ones)
                if prev_bit == 1 and bit == 1:
                    continue
                
                new_tight = tight and (bit == limit)
                new_started = started or (bit == 1)
                
                result += dp(pos + 1, bit, new_tight, new_started)
            
            memo[(pos, prev_bit, tight, started)] = result
            return result
        
        return dp(0, 0, True, False)
    
    # Test digit DP
    print("Digit DP Problems:")
    
    # Test digit sum counting
    test_cases_sum = [(100, 9), (1000, 15), (50, 7)]
    
    print("Numbers with specific digit sum:")
    for n, target in test_cases_sum:
        count = count_numbers_with_digit_sum(n, target)
        print(f"Numbers <= {n} with digit sum {target}: {count}")
    
    # Test consecutive ones
    print(f"\nNumbers without consecutive 1s in binary:")
    test_cases_consecutive = [10, 20, 100, 1000]
    
    for n in test_cases_consecutive:
        count = count_numbers_without_consecutive_ones(n)
        print(f"Numbers <= {n} without consecutive 1s: {count}")
        
        # Verify with brute force for small numbers
        if n <= 100:
            brute_force_count = 0
            for i in range(1, n + 1):
                binary_str = bin(i)[2:]
                if '11' not in binary_str:
                    brute_force_count += 1
            print(f"  Brute force verification: {brute_force_count} ({'✓' if count == brute_force_count else '✗'})")

digit_dp_problems()
```

### 3. Tree DP
```python
def tree_dp_problems():
    """Demonstrate DP on trees"""
    
    class TreeNode:
        def __init__(self, val=0):
            self.val = val
            self.children = []
    
    def tree_diameter(root):
        """Find diameter of tree using DP"""
        if not root:
            return 0
        
        max_diameter = 0
        
        def dfs(node):
            nonlocal max_diameter
            
            if not node:
                return 0
            
            # Get heights of all subtrees
            heights = []
            for child in node.children:
                heights.append(dfs(child))
            
            # Sort to get two largest heights
            heights.sort(reverse=True)
            
            # Diameter through current node
            if len(heights) >= 2:
                diameter = heights[0] + heights[1] + 2
            elif len(heights) == 1:
                diameter = heights[0] + 1
            else:
                diameter = 0
            
            max_diameter = max(max_diameter, diameter)
            
            # Return height of current subtree
            return (heights[0] + 1) if heights else 0
        
        dfs(root)
        return max_diameter
    
    def max_path_sum_tree(root):
        """Find maximum path sum in tree"""
        if not root:
            return 0
        
        max_sum = float('-inf')
        
        def dfs(node):
            nonlocal max_sum
            
            if not node:
                return 0
            
            # Get maximum path sums from children
            child_sums = []
            for child in node.children:
                child_sum = max(0, dfs(child))  # Don't include negative paths
                child_sums.append(child_sum)
            
            # Current node's contribution to path sum
            current_sum = node.val
            
            # Add all positive child contributions
            for child_sum in child_sums:
                current_sum += child_sum
            
            max_sum = max(max_sum, current_sum)
            
            # Return max sum path going through current node to parent
            max_child_sum = max(child_sums) if child_sums else 0
            return node.val + max_child_sum
        
        dfs(root)
        return max_sum
    
    def count_subtree_nodes(root):
        """Count nodes in each subtree"""
        if not root:
            return {}
        
        subtree_counts = {}
        
        def dfs(node):
            if not node:
                return 0
            
            count = 1  # Current node
            for child in node.children:
                count += dfs(child)
            
            subtree_counts[id(node)] = count
            return count
        
        dfs(root)
        return subtree_counts
    
    # Create test tree
    #       1
    #     / | \
    #    2  3  4
    #   /|     |\
    #  5 6     7 8
    
    root = TreeNode(1)
    node2 = TreeNode(2)
    node3 = TreeNode(3)
    node4 = TreeNode(4)
    node5 = TreeNode(5)
    node6 = TreeNode(6)
    node7 = TreeNode(7)
    node8 = TreeNode(8)
    
    root.children = [node2, node3, node4]
    node2.children = [node5, node6]
    node4.children = [node7, node8]
    
    print("Tree DP Problems:")
    print("Tree structure:")
    print("       1")
    print("     / | \\")
    print("    2  3  4")
    print("   /|     |\\")
    print("  5 6     7 8")
    
    # Test diameter
    diameter = tree_diameter(root)
    print(f"Tree diameter: {diameter}")
    
    # Test max path sum
    max_sum = max_path_sum_tree(root)
    print(f"Maximum path sum: {max_sum}")
    
    # Test subtree node counts
    counts = count_subtree_nodes(root)
    print(f"Subtree node counts:")
    node_map = {id(root): "1", id(node2): "2", id(node3): "3", id(node4): "4",
                id(node5): "5", id(node6): "6", id(node7): "7", id(node8): "8"}
    
    for node_id, count in counts.items():
        if node_id in node_map:
            print(f"  Node {node_map[node_id]}: {count} nodes in subtree")

tree_dp_problems()
```

## DP Optimization Techniques

### Space Optimization
```python
def dp_space_optimization():
    """Demonstrate space optimization techniques"""
    
    def fibonacci_space_optimized():
        """Fibonacci with O(1) space"""
        def fib(n):
            if n <= 1:
                return n
            
            prev2, prev1 = 0, 1
            for i in range(2, n + 1):
                current = prev1 + prev2
                prev2, prev1 = prev1, current
            
            return prev1
        
        return fib
    
    def coin_change_space_optimized():
        """Coin change with space optimization"""
        def min_coins(coins, amount):
            # Instead of 2D DP, use 1D array
            dp = [float('inf')] * (amount + 1)
            dp[0] = 0
            
            for coin in coins:
                for a in range(coin, amount + 1):
                    dp[a] = min(dp[a], dp[a - coin] + 1)
            
            return dp[amount] if dp[amount] != float('inf') else -1
        
        return min_coins
    
    def longest_common_subsequence_space_optimized():
        """LCS with O(min(m,n)) space"""
        def lcs_length(text1, text2):
            m, n = len(text1), len(text2)
            
            # Ensure text1 is shorter
            if m > n:
                text1, text2 = text2, text1
                m, n = n, m
            
            prev = [0] * (m + 1)
            curr = [0] * (m + 1)
            
            for i in range(1, n + 1):
                for j in range(1, m + 1):
                    if text2[i-1] == text1[j-1]:
                        curr[j] = prev[j-1] + 1
                    else:
                        curr[j] = max(prev[j], curr[j-1])
                
                prev, curr = curr, prev
            
            return prev[m]
        
        return lcs_length
    
    # Demonstrate space optimizations
    print("DP Space Optimization Techniques:")
    
    # Fibonacci
    fib = fibonacci_space_optimized()
    print(f"Fibonacci(20): {fib(20)} (using O(1) space)")
    
    # Coin change
    min_coins = coin_change_space_optimized()
    result = min_coins([1, 3, 4], 6)
    print(f"Min coins for amount 6: {result} (using O(amount) space)")
    
    # LCS
    lcs_length = longest_common_subsequence_space_optimized()
    result = lcs_length("ABCDGH", "AEDFHR")
    print(f"LCS length: {result} (using O(min(m,n)) space)")

dp_space_optimization()
```

### Time Optimization
```python
def dp_time_optimization():
    """Demonstrate time optimization techniques"""
    
    def matrix_exponentiation_fibonacci(n):
        """Fibonacci using matrix exponentiation - O(log n)"""
        def matrix_multiply(A, B):
            return [[A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
                    [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]]
        
        def matrix_power(matrix, power):
            if power == 1:
                return matrix
            
            if power % 2 == 0:
                half_power = matrix_power(matrix, power // 2)
                return matrix_multiply(half_power, half_power)
            else:
                return matrix_multiply(matrix, matrix_power(matrix, power - 1))
        
        if n <= 1:
            return n
        
        # Base matrix [[1, 1], [1, 0]]
        base_matrix = [[1, 1], [1, 0]]
        result_matrix = matrix_power(base_matrix, n)
        
        return result_matrix[0][1]
    
    def convex_hull_optimization():
        """Demonstrate convex hull optimization for DP"""
        # Example: Optimal binary search tree cost
        def optimal_bst_cost(frequencies):
            n = len(frequencies)
            
            # Prefix sums for range queries
            prefix_sum = [0] * (n + 1)
            for i in range(n):
                prefix_sum[i + 1] = prefix_sum[i] + frequencies[i]
            
            def get_sum(i, j):
                return prefix_sum[j + 1] - prefix_sum[i]
            
            # Standard DP approach
            dp = [[0] * n for _ in range(n)]
            
            for length in range(2, n + 1):
                for i in range(n - length + 1):
                    j = i + length - 1
                    dp[i][j] = float('inf')
                    
                    for k in range(i, j + 1):
                        cost = get_sum(i, j)
                        if k > i:
                            cost += dp[i][k - 1]
                        if k < j:
                            cost += dp[k + 1][j]
                        
                        dp[i][j] = min(dp[i][j], cost)
            
            return dp[0][n - 1] if n > 1 else 0
        
        return optimal_bst_cost
    
    # Compare optimizations
    import time
    
    print("DP Time Optimization Techniques:")
    
    # Matrix exponentiation vs regular DP for Fibonacci
    test_values = [20, 30, 40]
    
    print("Fibonacci computation comparison:")
    print("n  | Regular DP | Matrix Exp | Speedup")
    print("-" * 45)
    
    for n in test_values:
        # Regular DP
        start = time.time()
        dp = [0] * (n + 1) if n > 0 else [0]
        if n > 0:
            dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        regular_result = dp[n] if n >= 0 else 0
        regular_time = time.time() - start
        
        # Matrix exponentiation
        start = time.time()
        matrix_result = matrix_exponentiation_fibonacci(n)
        matrix_time = time.time() - start
        
        speedup = regular_time / matrix_time if matrix_time > 0 else float('inf')
        
        print(f"{n:2} | {regular_time:10.6f} | {matrix_time:10.6f} | {speedup:6.1f}x")
        print(f"   Results match: {regular_result == matrix_result}")

dp_time_optimization()
```

## Summary

Dynamic Programming is a powerful algorithmic paradigm for optimization problems:

### Core Principles:
1. **Optimal Substructure**: Problem can be broken into optimal subproblems
2. **Overlapping Subproblems**: Same subproblems solved multiple times
3. **Memoization**: Store results to avoid recomputation
4. **State Definition**: Clear identification of problem parameters

### Key Patterns:
- **Linear DP**: Fibonacci, climbing stairs, house robber
- **2D DP**: LCS, edit distance, knapsack, matrix chain
- **Interval DP**: Matrix multiplication, palindrome partitioning
- **Tree DP**: Diameter, path sums, subtree properties
- **Digit DP**: Number theory problems with constraints

### Optimization Techniques:
- **Space Optimization**: Reduce from O(n²) to O(n) or O(1)
- **Time Optimization**: Matrix exponentiation, convex hull trick
- **State Compression**: Bitmask DP for subset problems
- **Monotonic Queue**: Sliding window maximum optimization

### Applications:
- **Algorithms**: Shortest paths, sequence alignment
- **Optimization**: Resource allocation, scheduling
- **Game Theory**: Optimal strategies, minimax
- **Bioinformatics**: DNA sequence analysis
- **Computer Graphics**: Optimal polygon triangulation

Understanding DP enables solving complex optimization problems efficiently by recognizing patterns, defining states correctly, and choosing appropriate implementation strategies.